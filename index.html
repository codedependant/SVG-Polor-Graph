<!DOCTYPwindow.onload = function() { E html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
    <title>Arc Chart</title>
    
    <script type="application/x-javascript" src="raphael-min.js"></script>
    
    <script type="application/x-javascript">
        
    var month=new Array();
    month[0]="January";
    month[1]="February";
    month[2]="March";
    month[3]="April";
    month[4]="May";
    month[5]="June";
    month[6]="July";
    month[7]="August";
    month[8]="September";
    month[9]="October";
    month[10]="November";
    month[11]="December";        
        
        
        var paper;
        var center;
        
        var graphRadius = 200;
        var graphRadiusMax = 300;
        
        
        var titleText = "Some Graph for \n some data";
        
        var dataLabelDistance = graphRadius * 0.2;
        var axisLabelDistance = graphRadius * 0.1;
        
        
        var pointsCount = 12;
        
        var canvasWidth = 1000;
        var cancasHeight = 1000;
        
        
        window.onload = function() { 
            // Creates canvas 320 × 200 at 10, 50
            paper = Raphael("canvas", canvasWidth, cancasHeight);
            center = {x:paper.width/2,y:paper.height/2};
            
            var title = paper.text(center.x, center.y,titleText)
                        .attr("font-size","14px")
                        ;

            var pathPoints = generatePoints();
            
            
            var firstpoint;
            
            var animation_firstpoint;
            
            var path = "";
            var animation_path = "";
            
            console.log(pathPoints.length); 
            
            var dataLabels = [];
            
            for (var i = 0; i < pathPoints.length; i++)
            {
                
                
                var pathPoint = pathPoints[i];
                var dataLabelPoint = calculateCirclePoint(center,(pathPoint.dataRadius + dataLabelDistance),pathPoint.angle);                            
                var axisLabelPoint = calculateCirclePoint(center,(graphRadius-axisLabelDistance),pathPoint.angle);                  
                
                if(i==0)
                {
                    path += moveTo(pathPoint);//"M"+pathPoint.x+","+pathPoint.y;
                    firstpoint = pathPoint;
                    
                    
                    animation_path += moveTo(axisLabelPoint);//"M"+axisLabelPoint.x+","+axisLabelPoint.y;
                    animation_firstpoint = axisLabelPoint;
                    
                }
                else
                {
                    path += lineTo(pathPoint);//"L"+pathPoint.x+","+pathPoint.y;
                    
                    animation_path += lineTo(axisLabelPoint);//"L"+axisLabelPoint.x+","+axisLabelPoint.y;
                }   
                
              
                            
                //var c = paper.path("M"+axisLabelPoint.x+" "+axisLabelPoint.y+"L"+pathPoint.x+" "+pathPoint.y);
                
                
                
                var dataLabel = paper.text(dataLabelPoint.x,dataLabelPoint.y, "point ")
                .transform("r"+(pathPoint.angle*180/Math.PI +90 ))
                .attr("font-size","12px")
                .attr("opacity",0)
                ;
                dataLabels.push(dataLabel);
                
                paper.circle(pathPoint.x, pathPoint.y, 10)
                .data("i", i)
                .attr("opacity",0)
                .attr("fill","red")
                .mouseover(function(){
                    
                    console.log("over data point "+this.data("i"));
                    
                    dataLabels[this.data("i")].attr("opacity",1);
                    
                    title.attr("text","data "+this.data("i"));
                    
                    
                })
                .mouseout(function(){
                    console.log("out data point "+this.data("i"));
                    
                    dataLabels[this.data("i")].attr("opacity",0);
                    title.attr("text",titleText);
                });
                
                
                var axisLabel = paper.text(axisLabelPoint.x,axisLabelPoint.y, month[i])
                .transform("r"+(pathPoint.angle*180/Math.PI +90 ))
                .attr("opacity",1)
                .attr("font-size","12px")
                ;                
                
                
                
                
            }
            
            path += lineTo(firstpoint);//"L"+firstpoint.x+","+firstpoint.y;
            
            animation_path += lineTo(animation_firstpoint);// "L"+animation_firstpoint.x+","+animation_firstpoint.y;
                              
                              
            //drawn here so that when it is pushed back, it still ends up in front of daatPath and center circle, but not in front of data label circles                  
            drawGrid(pathPoints);
            
            
            var centerCircle = paper.circle(center.x, center.y, graphRadius)
                                .toBack()
                                .attr("fill","white")
                                .attr("opacity",1)
                                ;
                                
                                
            var graph = paper.path(animation_path)
                        .toBack()
                       .attr("fill","90-#333-#666");
                       
            graph.animate({path:path},600,"bounce");
            
            
            
            
            

        }
  
  
        function drawGrid(pathPoints)
        {
            var gridLinePath = '';
            for (var i = 0; i < pathPoints.length; i++)
            {
                            
                var pathPoint = pathPoints[i];
                
                var gridLineStartPoint = calculateCirclePoint(center,graphRadius,pathPoint.angle);
                var gridLineEndPoint = calculateCirclePoint(center,graphRadius+graphRadiusMax,pathPoint.angle);
                
                gridLinePath += line(gridLineStartPoint,gridLineEndPoint);
                
            }
            
            console.log(gridLinePath);            
            paper.path(gridLinePath)
            .attr("stroke","#BFBFBF")
            .attr("stroke-opacity",0.3)
            .toBack()
            ;
            
            var gridCircleSpacing = (graphRadius + graphRadiusMax)/15;
            var gridCircleNumber = (graphRadiusMax)/gridCircleSpacing;
            
            for (var i = 0; i < gridCircleNumber; i++)
            {
                
                var gridCircle = paper.circle(center.x,center.y,graphRadius+(i*gridCircleSpacing))
                .attr("stroke-opacity",0.3)
                .attr("stroke","#BFBFBF")
                .toBack()
                ;
                
                if(i==Math.round(gridCircleNumber/2))
                    gridCircle.attr("stroke","#FF6B6B");
                

                
            }
            
            
            
            
            
            
        }
        
        
        function moveTo(point)
        {
            return "M"+point.x+" "+point.y
        }
        
        function lineTo(point)
        {
            return "L"+point.x+" "+point.y
        }
        
        function line(startPoint,endPOint)
        {
            return moveTo(startPoint)+lineTo(endPOint);
        }
  

        function generatePoints()
        {
            
            
            var slice = 2 * Math.PI / pointsCount;            
            
           
            
            var pathPoints = [];
            var dataLabelPoints = [];
            var axisLabelPoints = [];
            
            var firstpoint;
            
                        
            var dataRadius = graphRadius ;
            for (var i = 0; i < pointsCount; i++)
            {
                
                dataRadius = graphRadius;
                dataRadius = graphRadius + Math.random()*graphRadiusMax;
                /*
                if(i!=0)
                    dataRadius +=  Math.random() * (graphRadiusMax/pointsCount) * 2;
                */
                
                var angle = slice * i;
                var cos_angle = Math.cos(angle);
                var sin_angle = Math.sin(angle);
                                  
                var pathPoint =
                {
                    x:Math.round(center.x + dataRadius * cos_angle),
                    y:Math.round(center.y + dataRadius * sin_angle),
                    angle:angle,
                    dataRadius:dataRadius
                };
                
                pathPoints.push(pathPoint);
                             
            }
                            
            return pathPoints;
            
        }
        
        function calculateCirclePoint(center,radius,angle)
        {
            var cos_angle = Math.cos(angle);
            var sin_angle = Math.sin(angle);            
            return {x: Math.round(center.x + radius * cos_angle) ,y:Math.round(center.y + radius * sin_angle)};
            
        }


    </script>
    
    
    
    
</head>
<body>
    <h1>SVG Polor Graph</h1>
    <div id="canvas">
    </div>
    
    
</body>
</html>
